<!doctype html>
<html>

<head>
	<title>Three.js Boilerplate</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>

	<script src="http://rawgithub.com/dataarts/dat.gui/master/build/dat.gui.min.js"></script>
	<script src="http://threejs.org/examples/js/controls/TrackballControls.js"></script>
	<script src="./OBJLoader.js"></script>


	<style>
		body {
			overflow: hidden;
			padding: 0;
			margin: 0;
			color: #222;
			background-color: #BBB;
			font-family: arial;
			font-size: 100%;
		}
	</style>
</head>

<body>
	<!-- three.js container -->
	<div id="container"></div>
	<!-- info on screen display -->
	<script type="x-shader/x-vertex" id="vertexShader">


		vec3 mod289(vec3 x)
		{
			return x - floor(x * (1.0 / 289.0)) * 289.0;
		}
		
		vec4 mod289(vec4 x)
		{
			return x - floor(x * (1.0 / 289.0)) * 289.0;
		}
		
		vec4 permute(vec4 x)
		{
			return mod289(((x*34.0)+1.0)*x);
		}
		
		vec4 taylorInvSqrt(vec4 r)
		{
			return 1.79284291400159 - 0.85373472095314 * r;
		}
		
		vec3 fade(vec3 t) {
			return t*t*t*(t*(t*6.0-15.0)+10.0);
		}
		
		// Classic Perlin noise
		float cnoise(vec3 P)
		{
			vec3 Pi0 = floor(P); // Integer part for indexing
			vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
			Pi0 = mod289(Pi0);
			Pi1 = mod289(Pi1);
			vec3 Pf0 = fract(P); // Fractional part for interpolation
			vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
			vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
			vec4 iy = vec4(Pi0.yy, Pi1.yy);
			vec4 iz0 = Pi0.zzzz;
			vec4 iz1 = Pi1.zzzz;
		
			vec4 ixy = permute(permute(ix) + iy);
			vec4 ixy0 = permute(ixy + iz0);
			vec4 ixy1 = permute(ixy + iz1);
		
			vec4 gx0 = ixy0 * (1.0 / 7.0);
			vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
			gx0 = fract(gx0);
			vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
			vec4 sz0 = step(gz0, vec4(0.0));
			gx0 -= sz0 * (step(0.0, gx0) - 0.5);
			gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		
			vec4 gx1 = ixy1 * (1.0 / 7.0);
			vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
			gx1 = fract(gx1);
			vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
			vec4 sz1 = step(gz1, vec4(0.0));
			gx1 -= sz1 * (step(0.0, gx1) - 0.5);
			gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		
			vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
			vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
			vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
			vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
			vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
			vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
			vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
			vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		
			vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
			g000 *= norm0.x;
			g010 *= norm0.y;
			g100 *= norm0.z;
			g110 *= norm0.w;
			vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
			g001 *= norm1.x;
			g011 *= norm1.y;
			g101 *= norm1.z;
			g111 *= norm1.w;
		
			float n000 = dot(g000, Pf0);
			float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
			float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
			float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
			float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
			float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
			float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
			float n111 = dot(g111, Pf1);
		
			vec3 fade_xyz = fade(Pf0);
			vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
			vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
			float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
			return 2.2 * n_xyz;
		}
		
		// Classic Perlin noise, periodic variant
		float pnoise(vec3 P, vec3 rep)
		{
			vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
			vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
			Pi0 = mod289(Pi0);
			Pi1 = mod289(Pi1);
			vec3 Pf0 = fract(P); // Fractional part for interpolation
			vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
			vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
			vec4 iy = vec4(Pi0.yy, Pi1.yy);
			vec4 iz0 = Pi0.zzzz;
			vec4 iz1 = Pi1.zzzz;
		
			vec4 ixy = permute(permute(ix) + iy);
			vec4 ixy0 = permute(ixy + iz0);
			vec4 ixy1 = permute(ixy + iz1);
		
			vec4 gx0 = ixy0 * (1.0 / 7.0);
			vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
			gx0 = fract(gx0);
			vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
			vec4 sz0 = step(gz0, vec4(0.0));
			gx0 -= sz0 * (step(0.0, gx0) - 0.5);
			gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		
			vec4 gx1 = ixy1 * (1.0 / 7.0);
			vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
			gx1 = fract(gx1);
			vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
			vec4 sz1 = step(gz1, vec4(0.0));
			gx1 -= sz1 * (step(0.0, gx1) - 0.5);
			gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		
			vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
			vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
			vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
			vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
			vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
			vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
			vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
			vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		
			vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
			g000 *= norm0.x;
			g010 *= norm0.y;
			g100 *= norm0.z;
			g110 *= norm0.w;
			vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
			g001 *= norm1.x;
			g011 *= norm1.y;
			g101 *= norm1.z;
			g111 *= norm1.w;
		
			float n000 = dot(g000, Pf0);
			float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
			float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
			float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
			float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
			float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
			float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
			float n111 = dot(g111, Pf1);
		
			vec3 fade_xyz = fade(Pf0);
			vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
			vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
			float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
			return 2.2 * n_xyz;
		}





		varying vec2 vUv;
		varying float noise;
		varying float displacement;
		uniform float time;
		uniform float noiseSize;
		uniform float  noiseHeight;
		varying float DEPTH ;

		uniform float FARPLANE ;
		float turbulence( vec3 p ) {
		
			float w = 100.0;
			float t = -.5;
		
			for (float f = 1.0 ; f <= 10.0 ; f++ ){
				float power = pow( 2.0, f );
				t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
			}
		
			return t;
		
		}
		
		void main() {
		
		//vUv = uv;
		float value = vUv.x;
			// add time to the noise parameters so it's animated
		//	noise = 10.0 *  -.10 * turbulence( .5 * normal + time );
		//	float b = 5.0 * pnoise( noiseSize * position + vec3( 2.0 * time ), vec3( 100.0 ) );
		//	float displacement = - noise + b;
		
			//vec3 newPosition = position + normal + abs(sin(value * 1.9 * 190.0 * 0.5 + time)) + displacement;
		vec3 sinusDisplacement = vec3(abs(sin(300.0 * 1.0 * 19.0 * 0.5 + time)));
		//	gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
		
		
		vUv = uv;

		// add time to the noise parameters so it's animated
		noise = 6.0 *  -.10 * turbulence( .5 * normal + time );
		float b = 7.0 * pnoise( noiseSize * position + vec3( 1.5 * time ), vec3( 100.0 ) ); // multiply sinusDisplacement  with noiseSize
		float bTwo = 7.0 * pnoise( 0.0 * position + vec3( 1.5 * time ), vec3( 100.0 ) );
		displacement = - clamp((noise) + (b * (- b * (noiseHeight / 20.0))) * (bTwo * 2.0), 0.0, 1.0) ; //0.5 factor of height
	
		vec3 newPosition = position + normal * (displacement * (displacement * 10.0) );
	//	newPosition *= sinusDisplacement;

		gl_Position = projectionMatrix * modelViewMatrix * vec4( (newPosition), 1.0 );// * (vec4(sinusDisplacement / 20.0, 1.0));
		//gl_Position *= projectionMatrix * modelViewMatrix * (vec4(sinusDisplacement , 1.0));
		DEPTH = ((gl_Position.z * 1.0) / (FARPLANE + 10.0));
	
	}

		</script>

	<script type="x-shader/x-vertex" id="fragmentShader">
		varying vec2 vUv;
		varying float noise;
		varying float displacement;
		uniform sampler2D texture;
		uniform sampler2D texturedetails;
		varying float DEPTH ;

		float random( vec3 scale, float seed ){
			return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed ) ;
		}

		void main() {
			vec3 pink = vec3(0.5, 0.09, 0.0);
			vec3 green = vec3(0.0, 1.0, 0.0);
			vec3 blue = vec3(0.0, 0.0, 1.0);


			float r = .01 * random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );

		//	float percent = abs(sin(vUv.x * 3.1415 * 200.0)); // Abstufungen
			float percent = smoothstep(0.27, 0.27, 12.0);
		//	vec3 color = vec3( vUv * ( 1. - 2. * noise ), 0.0 );
			vec3 color = vec3(0.5, 0.5, 0.5);
			color /= vec3((20.0 * 1.0 * 900.0) / (900.0 + 1.0 - DEPTH * (900.0 - 1.0))) / vec3(850.0);
			vec3 gradient = mix(pink, blue, percent);
			//color += gradient;
	//		gl_FragColor = vec4( color, 1.0 );
	vec2 tPos = vec2( 0, 29.3 * displacement + r ); //1.3
		vec4 text = texture2D( texture, vUv + (displacement / 10.0) * - displacement );
		text /= vec4((20.0 * 9.0 * 900.0) / (900.0 + 1.0 - DEPTH * (900.0 - 1.0))) / vec4(850.0);
		text -= texture2D(texturedetails, vUv + displacement);
		gl_FragColor = vec4( text.rgb, 1.0 );
		}
		</script>
	<script type="text/javascript">
		// import {OBJLoader2} from './resources/threejs/r112/examples/jsm/loaders/OBJLoader2.js';

		var stats, scene, renderer, composer, model;
		var start = Date.now();
		var camera, cameraControls;
		var Variables = function () {
			this.speed = 0.0;
			this.noiseHeight = 0.5;
			this.noiseSize = 0.09;
		}
		var variables = new Variables();
		var gui = new dat.GUI();
		gui.add(variables, 'speed', 0, 2);
		gui.add(variables, 'noiseHeight', 0, 2.0);
		gui.add(variables, 'noiseSize', 0, 0.5);
		if (!init()) animate();
		// init the scene
		function init() {
			renderer = new THREE.WebGLRenderer({
				antialias: true,	// to get smoother output
			});
			renderer.setClearColor(0x121212);//bbbbbb
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById('container').appendChild(renderer.domElement);
			// add Stats.js - https://github.com/mrdoob/stats.js
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.bottom = '0px';
			document.body.appendChild(stats.domElement);
			scene = new THREE.Scene();
			scene.fog = new THREE.Fog(0xbbbbbb, 35, 100);

			camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(0, 0, 350);
			scene.add(camera);
			cameraControls = new THREE.TrackballControls(camera, renderer.domElement)
			var geometry = new THREE.IcosahedronGeometry( 60, 5 ); //(16, 16, 50, 50);
			// var geometry = new THREE.PlaneGeometry(60, 60, 60, 60);; //(16, 16, 50, 50);
			var material = new THREE.ShaderMaterial({
				uniforms: {
					texture: {
						type: "t",
						value: THREE.ImageUtils.loadTexture('rainbow-texture.png')
					},
					texturedetails: {
						type: "t",
						value: THREE.ImageUtils.loadTexture('texture.png')
					},
					time: { // float initialized to 0
						type: "f",
						value: 0.0
					},
					noiseSize: {
						type: "f",
						value: variables.noiseSize, //0.09 for normal wobble
					},
					noiseHeight: {
						type: "f",
						value: variables.noiseHeight,
					},
					FARPLANE: {type: "f", value: 300.0},
        DEPTH: {type: "f", value: 5.0},
				},

				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent
			});
			// let material = new THREE.MeshNormalMaterial({wireframe: true});
			material.side = THREE.DoubleSide;

			var loader = new THREE.OBJLoader();
			loader.load('./model/triangle-try.obj', function (obj) {

				obj.traverse(function (child) {

					if (child instanceof THREE.Mesh) {

						child.material = material;

					}
					model = child
					scene.add(model);

				});
			});
		

			model = new THREE.Mesh(geometry, material);
			// scene.add(model);





		}
		function animate() {
			requestAnimationFrame(animate);
			render();
			stats.update();
		}
		function render() {
			var PIseconds = Date.now() * Math.PI;
			cameraControls.update();
			model.material.uniforms['time'].value = .00025 * (Date.now() - start);
			model.material.uniforms['noiseHeight'].value = variables.noiseHeight;
			model.material.uniforms['noiseSize'].value = variables.noiseSize;
			scene.traverse(function (object3d, i) {
				if (object3d instanceof THREE.Mesh === false) return
				object3d.rotation.y = variables.speed * PIseconds * 0.0003 * (i % 2 ? 1 : -1);
				object3d.rotation.x = variables.speed * PIseconds * 0.0002 * (i % 2 ? 1 : -1);
			})
			renderer.render(scene, camera);
		}
	</script>
</body>

</html>